template < typename T, bool any = false >
class FormalPowerSeries
{
  public:
    using  i64    = int64_t;
    using  FPS   = FormalPowerSeries<T, any>;
    using  VPoly = vector<FPS>;
    
	vector<T>  a;

  public:
    FormalPowerSeries( size_t sz = 0 )  { a.resize( sz, 0 ); }
    FormalPowerSeries( const initializer_list<T>  v )  { a = v; }
    FormalPowerSeries( const vector<T>  &v )  { a = v; }
    FormalPowerSeries( size_t sz, T val )  { a.resize( sz, val ); }
    size_t  size() const { return a.size(); }
    void  resize( size_t sz, T m = 0 )  { (*this).a.resize( sz, m ); }

    FPS  operator - ( const FPS &a ) const { return  FPS(*this) -= a; }
    FPS  operator + ( const FPS &a ) const { return  FPS(*this) += a; }
    FPS  operator * ( const i64 a )  const { return  FPS(*this) *= a; }
    FPS  operator * ( const FPS &a ) const { return  FPS(*this) *= a; }
    FPS  operator / ( const FPS &a ) const { return  FPS(*this) /= a; }
    FPS  operator % ( const FPS &a ) const { return  FPS(*this) %= a; }
    FPS  &operator += ( const FPS &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] += r.a[i];
        return  *this;
    }
    FPS  &operator -= ( const FPS &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] -= r.a[i];
        return  *this;
    }
    FPS  &operator *= ( const i64 v )  {
        for( size_t i=0 ; i<this->size() ; ++i )  this->a[i] *= v;
        return  *this;
    }
    FPS  &operator *= ( const FPS &r )  {
        this->convolution_inplace( r );
        return  *this;
    }
    FPS  &operator /= ( const FPS &r )  {  // = Q OF POLY DIVISION
        if( size() < r.size() )   return *this = FPS( 0 );
        int  n = this->size() - r.size() + 1;
        return *this = ( (*this).rev().low( n ) * r.rev().inverse( n ) ).low( n ).rev();
    }
    FPS  &operator %= ( const FPS &Q )  {
        if( Q.size() > size() )  return *this;
        if( Q.size() < 128 ) {
            int  dQ = Q.size() - 1;
            while( dQ  &&  Q[dQ] == 0 )  --dQ;
            assert( Q[dQ] != 0 );
            for( int i=size()-1 ; i>=dQ ; --i ) {
                if( a[i] == 0 )  continue;
                T  x = a[i] / Q[dQ];
                a[i] = 0;
                for( int j=1 ; j<=dQ ; ++j )
                    a[i-j] -= x * Q[dQ - j];
            }
            shrink();
            return  *this;
        }
        FPS  P = (*this) / Q;
        P *= Q;
        int  dR = -1;
        for( int i=0 ; i<Q.size()-1 ; ++i )  {
            P.a[i] = a[i] - P[i];
            if( P[i] != 0 )  dR = i;
        }
        a.resize( dR + 1 );
        for( int i=0 ; i<=dR ; ++i )  a[i] = P[i];
        shrink();
        return  size() == 0 ? (*this) = FPS( { 0 } ) : (*this );
    }
    FPS  low( int s ) const  {
        return FPS( { a.begin(), a.begin() + min( max( s, 1 ), int( size() ) ) } );
    }
    void shrink()  { while( a.size()  &&  a.back() == 0 )  a.pop_back(); }
    FPS  rev() const  {
        FPS  ret( *this );
        reverse( ret.a.begin(), ret.a.end() );
        return ret;
    }
    FPS  shift( int x )  { 
        FPS  ret = *this;
        if( x >= 0 )   ret.a.insert( begin( ret.a ), x, 0 );
        else  ret.a.erase( begin( ret.a ), begin( ret.a ) - x );
        return  ret; 
    }
    T  &operator [] ( size_t  x )  {
        assert( x < this->a.size() );
        return  a[x];
    }
    const T  &operator [] ( size_t  x ) const {
        assert( x < this->a.size() );
        return  a[x];
    }
    friend std::ostream &operator << ( std::ostream &os, const FPS &p )  {
        for( auto &v : p.a )   os << v << " ";
        return  os;
    }
    friend istream& operator >> ( istream& is, FPS &p )  {
	    for( auto &v : p.a )  { i64 w;  is >> w;  v = w; }   return  is;
    }

  private:    
    void ntt( bool inverse )  {
        static bool  first = true;
        static T  dw[30], idw[30];
        if( first )  {
            first = false;
            T  root = 2;
            unsigned  mod = T::get_mod();
            while( root.pow( (mod - 1) / 2) == 1 )   ++root;
            for( size_t i=0 ; i<30 ; ++i ) 
                dw[i]  = -root.pow( (mod - 1) >> (i + 2) ),
                idw[i] = T(1) / dw[i];
        }
        size_t  n = this->size();
        assert( (n & (n - 1) ) == 0 );
        if( not inverse )  {
            for( size_t m=n ; m >>= 1 ; )  {
                T  w = 1;
                for( size_t s=0, k=0 ; s<n ; s+=2*m )  {
                    for( size_t i=s, j=s+m ; i<s+m ; ++i, ++j )  {
                        T  x = a[i],  y = a[j]*w;
                        a[i] = x + y,  a[j] = x - y;
                    }
                    w *= dw[__builtin_ctz( ++k )];
                }
            }
        } else {
            for( size_t m=1 ; m<n ; m*=2 )  {
                T  w = 1;
                for( size_t s=0, k=0 ; s<n ; s+=2*m )  {
                    for( size_t i=s, j=s+m ; i<s+m ; ++i, ++j )  {
                        auto  x = a[i], y = a[j];
                        a[i] = x + y,  a[j] = x - y,  a[j] *= w;
                    }
                    w *= idw[__builtin_ctz( ++k )];
                }
            }
        }
        auto  c = T( 1 ) / T( inverse ? n : 1 );
        for( auto&& e : this->a )  e *= c;
    }
    
    FPS  convolution_brute( FPS &a, FPS &b ) const  {
        size_t  n = a.size(),  m = b.size();
        FPS  ans( n + m - 1 );
        if( n < m )
            for( size_t j=0 ; j<m ; ++j )
                for( size_t i=0 ; i<n ; ++i )   ans[i+j] += a[i]*b[j];
        else 
            for( size_t i=0 ; i<n ; ++i )
                for( size_t j=0 ; j<m ; ++j )   ans[i+j] += a[i]*b[j];
        return ans;
    }

    FPS&  convolution_inplace( FPS b )  {
        if( this->size() == 0  ||  b.size() == 0 )  {
            this->a.clear();  return  *this; }


        size_t  n = this->size(),  m = b.size(),  sz = 1 << __lg( 2*(n+m-1) - 1 );
        if( min( n, m ) <= 60 )   return  *this = convolution_brute( *this, b );
        resize( sz ),       ntt( false );
        b.resize( sz ),   b.ntt( false );
        for( size_t i=0 ; i<sz ; ++i )   a[i] *= b[i];
        ntt( true );  resize( n + m - 1 );
        return  *this;
    }


  public:
  // f(x)^-1 
    FPS  inverse( int dgr = -1 ) const  {
        size_t  n = this->size();
        assert( n != 0  &&  a[0] != 0 );
        size_t  deg = ( dgr == -1 ) ? n : size_t( dgr );
        FPS  r( { T( 1 ) / a[0] } );

        for( size_t m=1 ; m<deg ; m*=2 )  {
            size_t  twoM = m << 1;
            FPS  f( { a.begin(), a.begin() + min( n, twoM ) } );
            FPS  g( r );
            f.resize( twoM ),  f.ntt( false );
            g.resize( twoM ),  g.ntt( false );
            for( size_t i=0 ; i<twoM ; ++i )  f[i] *= g[i];
            f.ntt( true );
            f.a.erase( f.a.begin(), f.a.begin() + m );
            f.resize( twoM ),  f.ntt( false );
            for( size_t i=0 ; i<twoM ; ++i )  f[i] *= g[i];
            f.ntt( true ); 
            for( size_t i=0 ; i<twoM ; ++i )  f[i] = -f[i];
            r.a.insert( r.a.end(), f.a.begin(), f.a.begin() + m );
        }
        return  r.low( deg );
    }

  // f'(x)
    FPS&  differential_inplace()  {
        const size_t  n = this->a.size();
        assert( n > 0 );
        for( size_t i=1 ; i<n ; ++i )   a[i-1] = a[i] * i;
        a[n-1] = 0;
        return  *this;
    }
    FPS  differential() const { return  FPS( *this ).differential_inplace(); }

  // integral f(x)dx
    FPS&  integral_inplace() {
        const size_t  n = this->a.size();
        assert( n > 0 );
        this->a.insert( this->a.begin(), 0 );
        vector<T>  inv( n + 1 );   inv[1] = 1;
        unsigned  mod = T::get_mod();
        for( size_t i=2 ; i<=n ; ++i )  inv[i] = -inv[mod %i]*( mod/i );
        for( size_t i=2 ; i<=n ; ++i )  this->a[i] *= inv[i];
        return  *this;
    }
    FPS  integral() const { return FPS( *this ).integ_inplace(); }

  // exp(f(x)) 
    FPS&  exp_inplace( int deg = -1 )  {
        size_t  n = this->size();
        assert( n > 0  &&  a[0] == 0 );
        if( deg == -1 )  deg = int( n );
        FPS  g( { 1 } ),  g_fft;
        this->resize( deg );
        this->a[0] = 1;
        FPS  h_drv = this->differential();
        for( size_t m=1 ; m<deg ; m*=2 )  {
            FPS  f_fft( { a.begin(), a.begin() + m } );
            f_fft.resize( 2*m ), f_fft.ntt( false );
            T  invm = T( 1 ) / m;

            if( m > 1 )  {
                FPS  _f( m );
                for( size_t i=0 ; i<m ; ++i )  _f[i] = f_fft[i] * g_fft[i];
                _f.ntt( true );
                _f.a.erase( _f.a.begin(), _f.a.begin() + m/2 );
                _f.resize( m ),  _f.ntt( false );
                for( size_t i=0 ; i<m ; ++i )  _f[i] *= g_fft[i];
                _f.ntt( true );
                _f.resize( m/2 );
                for( size_t i=0 ; i<m/2 ; ++i )  _f[i] = -_f[i];
                g.a.insert( g.a.end(), _f.a.begin(), _f.a.begin() + m/2 );
            }

            FPS  t( { a.begin(), a.begin() + m } ); 
            t.differential_inplace();
            {
                FPS  r( { h_drv.a.begin(), h_drv.a.begin() + m - 1 } );
                r.resize( m );  r.ntt( false );
                for( size_t i=0 ; i<m ; ++i )  r[i] *= f_fft[i];
                r.ntt( true );
                t -= r;
                t.a.insert( t.a.begin(), t.a.back() );  t.a.pop_back();
            }

            t.resize( 2*m );  t.ntt( false ); 
            g_fft = g;  g_fft.resize( 2*m );  g_fft.ntt( false );
            for( size_t i=0 ; i<2*m ; ++i )  t[i] *= g_fft[i];
            t.ntt( true );
            t.resize( m );
            
            FPS  v( { a.begin() + m, a.begin() + min( deg, int( 2*m ) ) } );
            v.resize( m );
            t.a.insert( t.a.begin(), m-1, 0 );  t.a.push_back( 0 );
            
            t.integral_inplace();
            
            for( size_t i=0 ; i<m ; ++i )    v[i] -= t[m+i];
            v.resize( 2*m );  v.ntt( false );
            for( size_t i=0 ; i<2*m ; ++i )  v[i] *= f_fft[i];
            v.ntt( true );
            v.resize( m );

            for( size_t i=0 ; i<min( deg-m, m ) ; ++i )  a[m+i] = v[i];
        }
        return  *this;
    }   
    FPS  exp( const int deg = -1 ) const { return  FPS( *this ).exp_inplace( deg ); }

  // log(f(x)) 
    FPS&  log_inplace( int deg = -1 )  {
        size_t  n = this->size();
        assert( n > 0  &&  this->a[0] == 1 );
        if( deg == -1 )  deg = n;
        if( deg < n )    this->resize( deg );
        FPS  f_inv = this->inverse();
        this->differential_inplace();
        *this *= f_inv;
        this->resize( deg );
        this->integral_inplace();
        this->resize( deg );
        return  *this;
    }  
    FPS  log( const int deg = -1 ) const { return FPS( *this ).log_inplace( deg ); }

  // f(x)^k
    FPS&  pow_inplace( i64 k, int dgr = -1 )  {
        assert( dgr >= -1 );
        size_t  n = size();
        size_t  deg = ( dgr == -1 ) ? n : size_t( dgr );
        size_t  l = 0;
        while( this->a[l] == 0 )   ++l;
        if( k*l > deg )   return  *this = FPS( deg );
        T  ic = a[l].inverse();
        T  pc = a[l].pow( k );
        a.erase( a.begin(), a.begin() + l );
        *this *= ic.get();
        this->log_inplace();
        *this *= k;
        this->exp_inplace();
        *this *= pc.get();
        this->a.insert( this->a.begin(), l*k, 0 );
        this->resize( deg );
        return  *this;
    }
    FPS  pow( i64 k, int deg = -1 ) const { return FPS(*this).pow_inplace( k, deg ); }

  // f(g(x))
    FPS&  composition_inplace( const FPS &P )  {
        size_t  n = P.size();
        assert( n == size() );
        size_t  k = 1;
        while( uint64_t( k )*k < n )   ++k;

        VPoly  pow1( k + 1 );
        pow1[0] = { 1 };    pow1[1] = P;
        for( size_t i=2 ; i<=k ; ++i )  {
            pow1[i] = pow1[i-1] * pow1[1];
            pow1[i].resize( n );
        }
        VPoly  pow2( k + 1 );
        pow2[0] = { 1 };    pow2[1] = pow1[k];
        for( size_t i=2 ; i<=k ; ++i )  {
            pow2[i] = pow2[i-1] * pow2[1];
            pow2[i].resize( n );
        }
        FPS  ans( n );
        for( size_t i=0 ; i<=k ; ++i )  {
            FPS  f( n );
            for( size_t j=0 ; j<k ; ++j )  {
                if( k*i + j < n )  {
                    T coef = a[k*i + j];
                    for( size_t d=0 ; d<pow1[j].size() ; ++d )
                        f[d] += pow1[j][d]*coef;
                }
            } 
            f *= pow2[i];
            f.resize( n );
            for( size_t j=0 ; j<n ; ++j )  ans[j] += f[j];
        }
        a = ans.a;
        return  *this;
    }
    FPS  composition( const FPS &P ) { return FPS(*this).composition_inplace( P ); }

  // f(x)/g(x)  QUOTIENT USING / THEN CALC REMAINDER   
    pair<FPS, FPS>  divmod( const FPS &D )  {
        if( D.size() > this->size() )  return { {},*this };
        FPS  Q = (*this) / D;
        FPS  R = Q * D;
        int  n = D.size(),  j = -1;
        for( int i=0 ; i<n-1 ; ++i )  {
            R[i] = a[i] - R[i];
            if( R[i] != 0 )  j = i;
        }
        R.a.resize( j + 1 );
        return  { Q, R };
    }
    
  private:   // FOR MULTIPOINT EVALUATION AND POLYNOMIAL INTERPOLATION
    // BUILDS SEGMENT TREE  T  FOR  prod( x - pts[i] 
	// REF:  https://cp-algorithms.com/algebra/polynomial.html
    void  subprodTree( VPoly &tree, size_t rt, size_t l, size_t r )  
    {
        if( l + 1 == r )  {
            tree[rt] = { (*this)[l] == 0 ? 0 : -(*this)[l], 1 };
            return;
        }

        size_t  lKid = 2*rt,  rKid = lKid + 1,  mid  = ( l + r ) >> 1;
        subprodTree( tree, lKid, l, mid );
        subprodTree( tree, rKid, mid, r );
        tree[rt] = tree[lKid] * tree[rKid];
    }

    // QUERIES SEGMENT TREE tree TO EVALUATE p AT VALS IN pts.
    // STORES ANSWERS IN pts.
    void  multiPtEvaluation( const VPoly &tree, size_t rt, size_t l,
                             size_t r, FPS &p )  {
        if( l + 1 == r )  { (*this)[l] = p.size() == 0 ? 0 : p[0];  return; }

        size_t  lKid = 2*rt,  rKid = lKid + 1,  mid  = ( l + r ) >> 1;

        FPS  A = p % tree[lKid];
        multiPtEvaluation( tree, lKid, l, mid, A );
        A = p % tree[rKid];
        multiPtEvaluation( tree, rKid, mid, r, A );
    }

    FPS  interp( const VPoly &tree, size_t rt, size_t l, size_t r )
    {
        if( l + 1 == r )   return { (*this)[l] };

        size_t  lKid = 2*rt,   rKid = lKid + 1,   m = ( l + r ) >> 1;
        
        return  tree[rKid] * interp( tree, lKid, l, m ) +
                tree[lKid] * interp( tree, rKid, m, r );
    }
    
  public:
    // OVERWRITES pts WITH p EVALUATED AT pts
    FPS  multiPtEvaluation_IP( FPS& pts )
    {
        size_t  nSave = pts.size();
        if( size() == 0 )   return  FPS( nSave );
        pts.resize( max( size(), pts.size() ) );
        size_t  n = pts.size();
    
        // BUILD SEGMENT TREE FOR PRODUCTS
        VPoly  tree( n*4, FPS() );
        pts.subprodTree( tree, 1, 0, n );

        // QUERY SEGMENT TREE tree TO EVALUATE p AT pts
        pts.multiPtEvaluation( tree, 1, 0, n, (*this) );
        pts.resize( nSave );
        return  pts;
    }
    FPS  multiPtEvaluation( FPS &b ) {  FPS  tmp( b );
        return  (*this).multiPtEvaluation_IP( tmp ); }

    // GIVEN  n  ORDERED PAIRS ( a[i], b[i] ),  FIT A DEGREE n-1
    // POLYNOMIAL  f  SO THAT  f( a[i] ) %MOD = b[i]  FOR ALL i.
    FPS  interpolate_IP( const FPS &b )
    {
        size_t  n = b.size();
        assert( n == size() );

        VPoly  tree( 4*n, FPS() );
        (*this).subprodTree( tree, 1, 0, n );
        
        FPS  d = tree[1].differential();
        (*this).multiPtEvaluation( tree, 1, 0, n, d );

        for( size_t i=0 ; i<size() ; ++i )   (*this)[i] = b[i] / (*this)[i];
		  
        (*this) = (*this).interp( tree, 1, 0, n );
        
        (*this).resize( n );
        return  *this;
    }
    FPS  interpolate( const FPS &b ) { return  FPS( *this ).interpolate_IP( b ); }
    
  private:  // FOR k-th TERM OF LINEAR RECURRENCE - BOSTAN-MORI ALGORITHM
    friend void  half( FPS &A, bool odd )  {
        for( size_t i=odd ; i<A.size() ; i+=2 )   A[i >> 1] = A[i];
        A.resize( ( A.size() + !odd ) / 2 );
    }

    friend T  fps_kth_term( FPS &p, FPS &q, i64 k )  {
    	const size_t  sz = q.size();
        FPS  qneg;
        while( k > 0 )  {
        	qneg = q;
            for( size_t i=1 ; i<sz ; i+=2 )  qneg[i] = -qneg[i];
            p *= qneg;         q *= qneg;
            half( p,  k % 2 );  half( q, false );
            k >>= 1;
        }
        return  p[0] / q[0];
    }

  public:
      //  C = ( C[0], ..., C[m-1] )
      //  V = ( V[0], ..., V[m-1] )
	  //  RECURRENCE IS:
      //    V[i] = C[0]*V[i-1] + C[1]*V[i-2] + ... + C[m-1]*V[i-m]
    friend T  kth_term( const FPS &C, const FPS &V, i64 k )  {
    	const size_t  sz = C.size();
        FPS  q( sz + 1 );
        q[0] = 1;
        for( size_t i=0 ; i<sz ; ++i )   q[i + 1] = -C[i];
        FPS  p = V * q;
        p.resize( sz );
        return  fps_kth_term( p, q, k );
    }

    T  evaluate( i64 x )  {
        T  ans = 0,  powx = 1;
        for( auto &v : a )  {
            ans += v*powx;
            powx *= x;
       }
       return  ans;
    }

    vector<T>  findRoots()  {
        FPS  x = { 0, 1 };
        FPS  p = x.modPow( T::get_mod(), *this );
        if( p.size() < 2 )   p.resize( 2 );
        p.a[1] -= 1;
        FPS  q = p.polyGCD( *this );
        vector<T>  ans;
        q.findRootsDFS( ans );
        return  ans;
    }

    FPS  modPow( u64 k, FPS g )  {  // this ^k mod g
        assert( g.size() );
        auto  inv = g.rev().inverse();
        FPS   res{ 1 },  b( *this );
        while( k )  {
            if( k & 1 )  {
                res *= b;   res -= res/g * g;
                res.shrink();
            }
            b *= b;   b -= b/g * g;
            b.shrink();
            k >>= 1;
        }
        return  res;
    }

  private:  // THIS STUFF IS FOR POLYNOMIAL INVERSE
    using  Arr = array<FPS, 2>;
    using  Mat = array<Arr, 2>;

    VPoly  cut( VPoly a, int k )  {
        for( size_t i=0 ; i<2 ; ++i )   a[i] = a[i].shift( -k );
        return a;
    }
    friend Mat  operator * ( const Mat& a, const Mat& b )  {
        Mat  res;
        for( size_t i=0 ; i<2 ; ++i )
            for( size_t j=0 ; j<2 ; ++j )
                for( size_t k=0 ; k<2 ; ++k )
                    res[i][k] += a[i][j] * b[j][k];
        return res;
    }
    friend VPoly  operator * ( const Mat& A, const VPoly& b )  {
        VPoly  ret( 2 );
        for( int i=0 ; i<2 ; ++i )  {
            FPS  tmp = A[i][0] * b[0] + A[i][1] * b[1];
            tmp.shrink();
            ret[i] = tmp;
        }
        return ret;
    }
    Mat  getID()  {
        FPS  zro = FPS( { 0 } ),  one = FPS( { 1 } );
        Mat  ID  = { Arr{ one, zro }, Arr{ zro, one } };
        return  ID;
	}
    void  step( Mat& m, VPoly& A )  {
        auto [q, r] = A[0].divmod( A[1] );
        r.shrink();
        A = { A[1], r };
        FPS  temp1 = m[0][0] - q * m[1][0];  temp1.shrink();
        FPS  temp2 = m[0][1] - q * m[1][1];  temp2.shrink();
        m = { m[1], { temp1, temp2 } };
    }

    Mat  hGCD( VPoly A )  {
        size_t  sz = A[0].size()/2;
        if( A[1].size() <= sz )   return  getID();
        Mat  R = hGCD( cut( A, sz ) );    A = R * A;
        if( A[1].size() <= sz )   return  R;
        step( R, A );
        if( A[1].size() <= sz )   return  R;
        int  k = 2*sz + 1 - (int)A[0].size();
        return  hGCD( cut( A, k ) ) * R;
    }

    Mat  euclid( VPoly A )  {
        Mat  mat = hGCD( A );   A = mat * A;
        if( !A[1].size() )   return  mat;
        step( mat, A );
        if( !A[1].size() )   return  mat;
        return  euclid( A ) * mat;
    }

  public:
    FPS  polyGCD( const FPS &b )  {
        Mat  mat = getID();
        VPoly  A = { *this, b };
        step( mat, A );
        if( A[1].size() )   mat = euclid( A )* mat;
        FPS  gcd = mat[0][0] * (*this) + mat[0][1] * b;
        gcd.shrink();
        return  gcd;
    }

    // REF:  https://math.stackexchange.com/questions/124300/
    //       finding-inverse-of-polynomial-in-a-field
    //  RETURNS  INVERSE OF (*this) MOD  b
    //  IFF NO INVERSE EXITS, RETURNS ans WITH size > size of b
    FPS  polyInverse( const FPS &b )  {
        Mat  mat = getID();
        VPoly  A = { *this, b };
        step( mat, A );
        if( A[1].size() )   mat = euclid( A ) * mat;
        FPS  gcd = mat[0][0] * (*this) + mat[0][1] * b;
        gcd.shrink();
        if( gcd.size() != 1 )   return  FPS( b.size() + 1 );
        size_t  sz = mat[0][0].size();
        FPS  ans( sz );
        T  v = gcd[0].inverse();
        for( size_t i=0 ; i<sz ; ++i )   ans[i] = mat[0][0][i] * v;
        ans.shrink();
        return  ans;
    }
  private:
    constexpr FPS  low( int s ) const  {
        return FPS( { a.begin(), a.begin() + min( max( s, 1 ), int( size() ) ) } );
    }
    void  shrink()  { while( a.size()  &&  a.back() == 0 )  a.pop_back(); }
    FPS  rev() const  {
        FPS  ret( *this );
        reverse( ret.a.begin(), ret.a.end() );
        return  ret;
    }
    constexpr FPS  shift( int x )  {
        FPS  ret = *this;
        if( x >= 0 )   ret.a.insert( begin( ret.a ), x, 0 );
        else  ret.a.erase( begin( ret.a ), begin( ret.a ) - x );
        return  ret;
    }

    void  findRootsDFS( vector<T> &roots )  {
        static std::mt19937  rng{ 0 };
        if( size() == 1 )  return;
        if( size() == 2 )  {
            roots.push_back( -a[0] / a[1] );
            return;
        }
        FPS  u { T( rng() ), T( 1 ) };
        FPS  v = u.modPow( ( T::get_mod() - 1 )/2, *this );
        --v[0];
        FPS  g = v.polyGCD( *this );
        g.findRootsDFS( roots );
        FPS  Q = (*this) / g;
        Q.findRootsDFS( roots );
    }
};
