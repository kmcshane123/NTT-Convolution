// SOLVES CONVOLUTION MOD 1000000007
// https://judge.yosupo.jp/problem/convolution_mod_1000000007

#include <cstdint>
#include <iostream>
#include <vector>
#include <algorithm>
#include <array>
#include <cassert>
using namespace std;

using  u64 = uint64_t;
using  u32 = uint32_t;

template <uint32_t mod>  // MOD INT STORED IN MONTGOMERY FORM
class  Mint
{
  private:
    using  i32 = int32_t;    using  i64 = int64_t;
    using  u32 = uint32_t;   using  u64 = uint64_t;

    static constexpr u32  get_r()  {
        u32  ret = mod;
        for( i32 i=0 ; i<4 ; ++i )  ret *= 2 - mod * ret;
        return  ret;
    }

    static constexpr u32  reduce( const u64 &b )  {
        return ( b + u64( u32( b ) * u32( -r ) ) * mod ) >> 32;
    }

    // CLASS MEMBER DATA
    static constexpr u32  r  = get_r();
    static constexpr u32  n2 = -u64( mod ) % mod;
	u32                   a;

    static_assert( r * mod == 1, "invalid, r * mod != 1" );
    static_assert( mod < (1 << 30), "invalid, mod >= 2 ^ 30" );
    static_assert( (mod & 1) == 1, "invalid, mod % 2 == 0" );

  public:
    // CONSTRUCTORS
    constexpr Mint() : a( 0 ) {}
    constexpr Mint( i64 b )
        : a( reduce( u64( b % mod + mod ) * n2 ) ) {};

    // ARITMETIC OPERATORS
    constexpr Mint &operator += ( const Mint &b )  {
        if( i32( a += b.a - 2 * mod ) < 0 )   a += 2 * mod;
        return  *this;
    }
    constexpr Mint &operator -= ( const Mint &b )  {
        if( i32( a -= b.a ) < 0 )   a += 2 * mod;
        return  *this;
    }
    constexpr Mint &operator *= ( const Mint &b )  {
        a = reduce( u64( a ) * b.a );
        return  *this;
    }
    constexpr Mint &operator /= ( const Mint &b )  {
        *this *= b.inverse();
        return  *this;
    }

    constexpr Mint operator  + (const Mint &b) const { return Mint(*this) += b; }
    constexpr Mint operator  - (const Mint &b) const { return Mint(*this) -= b; }
    constexpr Mint operator  * (const Mint &b) const { return Mint(*this) *= b; }
    constexpr Mint operator  / (const Mint &b) const { return Mint(*this) /= b; }
    constexpr Mint operator - () const {  return  Mint() - Mint(*this); }
    Mint& operator         ++ ()  { return  *this += Mint( 1 ); }
    Mint& operator         -- ()  { return  *this -= Mint( 1 ); }

    constexpr Mint  pow( u64 n ) const  {
        Mint  ret(  1 ), mul( *this );
        while( n > 0 )  { if( n & 1 )  ret *= mul;   mul *= mul;  n >>= 1; }
        return  ret;
    }
    constexpr Mint  inverse() const { return  pow( mod - 2 ); }
    constexpr u32  get() const  {
        u32  ret = reduce( a );
        return  ret >= mod ? ret - mod : ret;
    }
    static constexpr u32  get_mod()  { return mod; }

    constexpr bool operator == (const Mint &b) const {
        return ( a >= mod ? a - mod : a ) == ( b.a >= mod ? b.a - mod : b.a );
    }
    constexpr bool operator != (const Mint &b) const  {
        return ( a >= mod ? a - mod : a ) != ( b.a >= mod ? b.a - mod : b.a );
    }

    // INPUT AND OUTPUT
    friend ostream &operator << ( ostream &os, const Mint &b )  {
        return  os << b.get();
    }
    friend istream &operator >> ( istream &is, Mint &b )  {
        int64_t  t;  is >> t;
        b = Mint( t );
        return  is;
    }
};

template < typename T >
class FormalPowerSeries
{
  public:
    using  i64   = int64_t;
    using  FPS   = FormalPowerSeries<T>;

    // CLASS DATA
    vector<T>  a;

  public:
    // CONSTRUCTORS
    constexpr FormalPowerSeries( size_t sz = 0 )  { a.resize( sz, 0 ); }
    constexpr FormalPowerSeries( const initializer_list<T>  v )  { a = v; }
    constexpr FormalPowerSeries( const vector<T>  &v )  { a = v; }
    constexpr FormalPowerSeries( size_t sz, T val )  { a.resize( sz, val ); }
    constexpr size_t  size() const { return a.size(); }
    void  resize( size_t sz, T m = 0 )  { (*this).a.resize( sz, m ); }

    T  &operator [] ( size_t  x )  {
        assert( x < this->a.size() );
        return  a[x];
    }
    constexpr T  operator [] ( size_t  x ) const {
        assert( x < this->a.size() );
        return  a[x];
    }

    // INPUT AND OUTPUT
    friend std::ostream &operator << ( std::ostream &os, const FPS &p )  {
        for( auto &v : p.a )   os << v << " ";
        return  os;
    }
    friend istream& operator >> ( istream& is, FPS &p )  {
        for( auto &v : p.a )  { i64 w;  is >> w;  v = w; }   return  is;
    }

    // MATHEMATICAL OPERATORS
    constexpr FPS  operator - ( const FPS &a ) const { return  FPS(*this) -= a; }
    constexpr FPS  operator + ( const FPS &a ) const { return  FPS(*this) += a; }
    constexpr FPS  operator * ( const i64 a  ) const { return  FPS(*this) *= a; }
    constexpr FPS  operator * ( const FPS &a ) const { return  FPS(*this) *= a; }
    constexpr FPS  operator / ( const FPS &a ) const { return  FPS(*this) /= a; }
    constexpr FPS  operator % ( const FPS &a ) const { return  FPS(*this) %= a; }
    FPS  &operator = ( const FPS &r )  {
        this->a = r.a;
        return  *this;
    }
    FPS  &operator += ( const FPS &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] += r.a[i];
        return  *this;
    }
    FPS  &operator -= ( const FPS &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] -= r.a[i];
        return  *this;
    }
    FPS  &operator *= ( const i64 v )  {
        for( size_t i=0 ; i<this->size() ; ++i )  this->a[i] *= v;
        return  *this;
    }
    FPS  &operator *= ( const FPS &r )  {
        this->convolution_inplace( r );
        return  *this;
    }
    FPS  &operator /= ( const FPS &r )  {  // = Q OF POLY DIVISION
        if( size() < r.size() )   return *this = FPS( 0 );
        int  n = this->size() - r.size() + 1;
        if( (int)r.size() <= 32 )  {
            FPS  f( *this ),  g( r );
            g.shrink();
            int  coeff = g.a.back().inv().v;
            g *= coeff;
            int  deg = (int)f.size() - (int)g.size() + 1;
            int  gs  = g.size();
            FPS  quo( deg );
            for( int i=deg-1 ; i>=0 ; --i )  {
                quo[i] = f[i+gs-1];
                for( int j=0 ; j<gs ; ++j )  f[i+j] -= quo[i] * g[j];
            }
            *this = quo * coeff;
            this->resize( n, 0 );
            return *this;
        }
        return *this = ( (*this).rev().low( n ) * r.rev().inverse( n ) ).low( n ).rev();
    }
    FPS  &operator %= ( const FPS &Q )  {
        if( Q.size() > size() )  return *this;
        if( Q.size() < 128 )  {
            int  dQ = Q.size() - 1;
            while( dQ  &&  Q[dQ] == 0 )  --dQ;
            assert( Q[dQ] != 0 );
            for( int i=size()-1 ; i>=dQ ; --i ) {
                if( a[i] == 0 )  continue;
                T  x = a[i] / Q[dQ];
                a[i] = 0;
                for( int j=1 ; j<=dQ ; ++j )
                    a[i-j] -= x * Q[dQ - j];
            }
            shrink();
            return  *this;
        }
        FPS  P = (*this) / Q;
        P *= Q;
        int  dR = -1;
        for( int i=0 ; i<Q.size()-1 ; ++i )  {
            P.a[i] = a[i] - P[i];
            if( P[i] != 0 )  dR = i;
        }
        a.resize( dR + 1 );
        for( int i=0 ; i<=dR ; ++i )  a[i] = P[i];
        shrink();
        return  size() == 0 ? (*this) = FPS( { 0 } ) : (*this );
    }

    FPS  convolution_brute(const FPS &a, const FPS &b ) const  {
        size_t  n = a.size(),  m = b.size();
        FPS  ans( n + m - 1 );
        if( n < m )
            for( size_t j=0 ; j<m ; ++j )
                for( size_t i=0 ; i<n ; ++i )   ans[i+j] += a[i]*b[j];
        else
            for( size_t i=0 ; i<n ; ++i )
                for( size_t j=0 ; j<m ; ++j )   ans[i+j] += a[i]*b[j];
        return ans;
    }

  private:
    constexpr FPS  low( int s ) const  {
        return FPS( { a.begin(), a.begin() + min( max( s, 1 ), int( size() ) ) } );
    }
    void shrink()  { while( a.size()  &&  a.back() == 0 )  a.pop_back(); }
    FPS  rev() const  {
        FPS  ret( *this );
        reverse( ret.a.begin(), ret.a.end() );
        return ret;
    }
    constexpr FPS  shift( int x )  {
        FPS  ret = *this;
        if( x >= 0 )   ret.a.insert( begin( ret.a ), x, 0 );
        else  ret.a.erase( begin( ret.a ), begin( ret.a ) - x );
        return  ret;
    }

    void ntt( bool inverse )  {
        static bool  first = true;
        static T  dw[30], idw[30];
        if( first )  {
            first = false;
            T  root = 2;
            unsigned  mod = T::get_mod();
            while( root.pow( (mod - 1) / 2) == 1 )   ++root;
            for( size_t i=0 ; i<30 ; ++i )
                dw[i]  = -root.pow( (mod - 1) >> (i + 2) ),
                idw[i] = T(1) / dw[i];
        }
        size_t  n = this->size();
        assert( (n & (n - 1) ) == 0 );
        if( not inverse )  {
            for( size_t m=n ; m >>= 1 ; )  {
                T  w = 1;
                for( size_t s=0, k=0 ; s<n ; s+=2*m )  {
                    for( size_t i=s, j=s+m ; i<s+m ; ++i, ++j )  {
                        T  x = a[i],  y = a[j]*w;
                        a[i] = x + y,  a[j] = x - y;
                    }
                    w *= dw[__builtin_ctz( ++k )];
                }
            }
        } else {
            for( size_t m=1 ; m<n ; m*=2 )  {
                T  w = 1;
                for( size_t s=0, k=0 ; s<n ; s+=2*m )  {
                    for( size_t i=s, j=s+m ; i<s+m ; ++i, ++j )  {
                        auto  x = a[i], y = a[j];
                        a[i] = x + y,  a[j] = x - y,  a[j] *= w;
                    }
                    w *= idw[__builtin_ctz( ++k )];
                }
            }
        }
        auto  c = T( 1 ) / T( inverse ? n : 1 );
        for( auto&& e : this->a )  e *= c;
    }

    FPS&  convolution_inplace( FPS b )  {
        if( this->size() == 0  ||  b.size() == 0 )  {
            this->a.clear();  return  *this; }

        size_t  n = this->size(),  m = b.size(),  sz = 1 << __lg( 2*(n+m-1) - 1 );
        if( min( n, m ) <= 60 )   return  *this = convolution_brute( *this, b );
        resize( sz ),       ntt( false );
        b.resize( sz ),   b.ntt( false );
        for( size_t i=0 ; i<sz ; ++i )   a[i] *= b[i];
        ntt( true );  resize( n + m - 1 );
        return  *this;
    }
};

template < typename T >
class FormalPowerSeriesArb : public FormalPowerSeries<T>
{
  public:
    using  i32 = int32_t;    using  i64 = int64_t;
    using  u32 = uint32_t;   using  u64 = uint64_t;

    // CLASS DATA
    static constexpr u32  M1 = 962592769, M2 = 975175681, M3 = 976224257,
                          M4 = 985661441, M5 = 998244353;
    static constexpr const array<u32, 5>  mods{ M1, M2, M3, M4, M5 };
    inline static  vector<vector<u32>>    table_coeff;
    inline static  vector<u32>            table_coeffinv;
    inline static u32                     MOD;

    using  FPSA = FormalPowerSeriesArb<T>;
    using  FPSB = FormalPowerSeries<T>;
    using  FPS1 = FormalPowerSeries< Mint<M1> >;
    using  FPS2 = FormalPowerSeries< Mint<M2> >;
    using  FPS3 = FormalPowerSeries< Mint<M3> >;

  public:
    // CONSTRUCTORS
    constexpr FormalPowerSeriesArb( size_t sz )  { FPSB::a.resize( sz, 0 );  init(); }
    constexpr FormalPowerSeriesArb( const vector<T>  &v )  { FPSB::a = v;  init(); }
    constexpr FormalPowerSeriesArb( size_t sz, T val )  { FPSB::a.resize( sz, val );  init(); }
    constexpr FormalPowerSeriesArb()  { init(); }
    constexpr FormalPowerSeriesArb( const initializer_list<T>  v )  { FPSB::a = v; init(); }

    // INPUT
    friend istream& operator >> ( istream& is, FPSA &p )  {
        vector<i64>  work( p.size() );
        for( auto &v : work )  { is >> v; }
        u64  carry = 0;
        for( size_t i=0 ; i<p.size() ; ++i  )  {
            u64  cur = work[i] + carry;
            p.a[i] = T( cur );
            carry = cur/MOD;
        }
        if( carry )  p.a.push_back( T( carry ) );
	    return  is;
    }

    // ARITHMETIC OPERATORS
    constexpr FPSA  operator * ( const FPSA &a ) const { return  FPSA(*this) *= a; }

    FPSA  &operator = ( const FPSA &r )  {
        this->a = r.a;
        return  *this;
    }
    FPSA  &operator *= ( const FPSA &r )  {
        FPSA::convolution_inplace( r );
        return  *this;
    }

  private:
    static void  init()  {
        static bool  initialized = false;
        if( !initialized )  {
           setUpGarner();
           MOD = T::get_mod();
           initialized = true;
        }
    }

    FPSA  convolution_inplace( const FPSA &b )  {
        if( this->size() == 0  ||  b.size() == 0 )  {
            this->a.clear();  return  *this; }

        size_t  n = this->size(),  m = b.size();
        if( min( n, m ) <= 60 )  {
            auto  G = FPSB::convolution_brute( (*this), b );
            (*this).a = G.a;
            return  (*this);
        }
        return  convolve( (*this), b );
    }

    static u64  powm( u64 a, u64 i, u64 m )  {
        u64  r = a,  res = 1;
        while( i )  {
            if( i & 1 )   res = res * r % m;
            r = r * r % m;   i >>= 1;
        }
        return  res;
    }

    static u32  invm( u32 a, u32 m )  {	return  powm( a, m - 2, m ); }
    void  resize( size_t sz, T m = 0 )  { (*this).a.resize( sz, m ); }

    static void setUpGarner()  {
        table_coeff.assign( 4, vector<u32>( 3, 1 ) );
        for( size_t j=0 ; j<3 ; ++j )  {
            for( size_t k=0 ; k<3 ; ++k )   table_coeff[j+1][k] = table_coeff[j][k];
            for( size_t k=j+1 ; k<3 ; ++k )
                table_coeff[j+1][k] = (u64)table_coeff[j+1][k] * mods[j] % mods[k];
        }
        table_coeffinv.resize( 3 );
        for( size_t i=0 ; i<3 ; ++i )
            table_coeffinv[i] = invm( table_coeff[i][i], mods[i] );
    }

    static u64  garner( const vector<u32> &x )  {
        vector<u32>  table_const( 3 );
        u64  res_coeff = 1;
        u64  res = 0;
        for( size_t j=0 ; j<3 ; ++j )  {
            u64  t = (u64)( x[j] + mods[j] - table_const[j] ) * table_coeffinv[j] % mods[j];
            for( size_t k=j+1 ; k<3 ; ++k )
                table_const[k] = ( table_const[k] + (u64)table_coeff[j][k] * t ) % mods[k];
            res = ( res + res_coeff * u64( t ) ) %MOD;
            res_coeff = res_coeff * mods[j] %MOD;
        }
        return  res;
    }

    FPSA  convolve( const FPSA &A, const FPSA &B )  {
        size_t  n = A.size(),  m = B.size();
        FPS1  a1( n ), b1( m );  FPS2  a2( n ), b2( m );  FPS3  a3( n ), b3( m );

        for( size_t i=0 ; i<n ; ++i )  {
            u64  x = A[i].get();
            a3[i] = x %M3;  a2[i] = x %M2;  a1[i] = x %M1;
	}
        for( size_t i=0 ; i<m ; ++i )  {
            u64  x = B[i].get();
            b3[i] = x %M3;  b2[i] = x %M2;  b1[i] = x %M1;
        }
        a3 *= b3;  a2 *= b2;  a1 *= b1;

        FPSB::a.resize( a1.size() ) ;
        for( size_t i=0 ; i<a1.size() ; ++i )
            FPSB::a[i] = garner( { a1.a[i].get(), a2.a[i].get(), a3.a[i].get() } );
        return  *this;
    }
};

using  F = FormalPowerSeriesArb< Mint<1000000007> >;


int main()
{
    ios_base::sync_with_stdio( false );
    cin.tie( NULL );

    int N, M;
    cin >> N >> M;

    F  x( N ), y( M );
    cin >> x >> y;

    cout << x * y << '\n';

    return  0;
}
